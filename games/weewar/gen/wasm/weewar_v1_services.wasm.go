//go:build js && wasm
// +build js,wasm

// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: weewar/v1/models.proto

package weewar_v1_services

import (
	"context"
	"encoding/json"
	"fmt"
	"syscall/js"
	"time"

	"google.golang.org/protobuf/encoding/protojson"
	weewarv1 "github.com/panyam/turnengine/games/weewar/gen/go/weewar/v1"
)

// Weewar_v1_servicesServicesExports provides WASM exports for dependency injection
type Weewar_v1_servicesServicesExports struct {
	GamesService  weewarv1.GamesServiceServer
	UsersService  weewarv1.UsersServiceServer
	WorldsService weewarv1.WorldsServiceServer
}

// RegisterAPI registers the services with the JavaScript global namespace
func (exports *Weewar_v1_servicesServicesExports) RegisterAPI() {
	fmt.Println("weewar_v1_services WASM module loading...")
	// Create namespaced API structure
	weewar := map[string]interface{}{
		"gamesService": map[string]interface{}{
			"createGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceCreateGame(this, args)
			}),
			"getGames": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceGetGames(this, args)
			}),
			"listGames": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceListGames(this, args)
			}),
			"getGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceGetGame(this, args)
			}),
			"deleteGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceDeleteGame(this, args)
			}),
			"updateGame": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceUpdateGame(this, args)
			}),
			"processMoves": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.gamesServiceProcessMoves(this, args)
			}),
		},
		"usersService": map[string]interface{}{
			"createUser": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.usersServiceCreateUser(this, args)
			}),
			"getUsers": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.usersServiceGetUsers(this, args)
			}),
			"listUsers": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.usersServiceListUsers(this, args)
			}),
			"getUser": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.usersServiceGetUser(this, args)
			}),
			"deleteUser": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.usersServiceDeleteUser(this, args)
			}),
			"updateUser": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.usersServiceUpdateUser(this, args)
			}),
		},
		"worldsService": map[string]interface{}{
			"createWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceCreateWorld(this, args)
			}),
			"getWorlds": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceGetWorlds(this, args)
			}),
			"listWorlds": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceListWorlds(this, args)
			}),
			"getWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceGetWorld(this, args)
			}),
			"deleteWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceDeleteWorld(this, args)
			}),
			"updateWorld": js.FuncOf(func(this js.Value, args []js.Value) any {
				return exports.worldsServiceUpdateWorld(this, args)
			}),
		},
	}
	js.Global().Set("weewar", js.ValueOf(weewar))

	fmt.Println("weewar_v1_services WASM module loaded successfully")
}

// =============================================================================
// WASM API Functions - Generated Method Wrappers
// =============================================================================

// gamesServiceCreateGame handles the CreateGame method for GamesService
func (exports *Weewar_v1_servicesServicesExports) gamesServiceCreateGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return createJSResponse(false, "GamesService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.CreateGameRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.CreateGame(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceGetGames handles the GetGames method for GamesService
func (exports *Weewar_v1_servicesServicesExports) gamesServiceGetGames(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return createJSResponse(false, "GamesService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.GetGamesRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.GetGames(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceListGames handles the ListGames method for GamesService
func (exports *Weewar_v1_servicesServicesExports) gamesServiceListGames(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return createJSResponse(false, "GamesService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.ListGamesRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.ListGames(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceGetGame handles the GetGame method for GamesService
func (exports *Weewar_v1_servicesServicesExports) gamesServiceGetGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return createJSResponse(false, "GamesService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.GetGameRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.GetGame(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceDeleteGame handles the DeleteGame method for GamesService
func (exports *Weewar_v1_servicesServicesExports) gamesServiceDeleteGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return createJSResponse(false, "GamesService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.DeleteGameRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.DeleteGame(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceUpdateGame handles the UpdateGame method for GamesService
func (exports *Weewar_v1_servicesServicesExports) gamesServiceUpdateGame(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return createJSResponse(false, "GamesService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.UpdateGameRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.UpdateGame(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// gamesServiceProcessMoves handles the ProcessMoves method for GamesService
func (exports *Weewar_v1_servicesServicesExports) gamesServiceProcessMoves(this js.Value, args []js.Value) any {
	if exports.GamesService == nil {
		return createJSResponse(false, "GamesService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.ProcessMovesRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.GamesService.ProcessMoves(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// usersServiceCreateUser handles the CreateUser method for UsersService
func (exports *Weewar_v1_servicesServicesExports) usersServiceCreateUser(this js.Value, args []js.Value) any {
	if exports.UsersService == nil {
		return createJSResponse(false, "UsersService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.CreateUserRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.UsersService.CreateUser(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// usersServiceGetUsers handles the GetUsers method for UsersService
func (exports *Weewar_v1_servicesServicesExports) usersServiceGetUsers(this js.Value, args []js.Value) any {
	if exports.UsersService == nil {
		return createJSResponse(false, "UsersService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.GetUsersRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.UsersService.GetUsers(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// usersServiceListUsers handles the ListUsers method for UsersService
func (exports *Weewar_v1_servicesServicesExports) usersServiceListUsers(this js.Value, args []js.Value) any {
	if exports.UsersService == nil {
		return createJSResponse(false, "UsersService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.ListUsersRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.UsersService.ListUsers(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// usersServiceGetUser handles the GetUser method for UsersService
func (exports *Weewar_v1_servicesServicesExports) usersServiceGetUser(this js.Value, args []js.Value) any {
	if exports.UsersService == nil {
		return createJSResponse(false, "UsersService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.GetUserRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.UsersService.GetUser(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// usersServiceDeleteUser handles the DeleteUser method for UsersService
func (exports *Weewar_v1_servicesServicesExports) usersServiceDeleteUser(this js.Value, args []js.Value) any {
	if exports.UsersService == nil {
		return createJSResponse(false, "UsersService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.DeleteUserRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.UsersService.DeleteUser(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// usersServiceUpdateUser handles the UpdateUser method for UsersService
func (exports *Weewar_v1_servicesServicesExports) usersServiceUpdateUser(this js.Value, args []js.Value) any {
	if exports.UsersService == nil {
		return createJSResponse(false, "UsersService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.UpdateUserRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.UsersService.UpdateUser(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceCreateWorld handles the CreateWorld method for WorldsService
func (exports *Weewar_v1_servicesServicesExports) worldsServiceCreateWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return createJSResponse(false, "WorldsService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.CreateWorldRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.CreateWorld(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceGetWorlds handles the GetWorlds method for WorldsService
func (exports *Weewar_v1_servicesServicesExports) worldsServiceGetWorlds(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return createJSResponse(false, "WorldsService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.GetWorldsRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.GetWorlds(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceListWorlds handles the ListWorlds method for WorldsService
func (exports *Weewar_v1_servicesServicesExports) worldsServiceListWorlds(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return createJSResponse(false, "WorldsService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.ListWorldsRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.ListWorlds(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceGetWorld handles the GetWorld method for WorldsService
func (exports *Weewar_v1_servicesServicesExports) worldsServiceGetWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return createJSResponse(false, "WorldsService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.GetWorldRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.GetWorld(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceDeleteWorld handles the DeleteWorld method for WorldsService
func (exports *Weewar_v1_servicesServicesExports) worldsServiceDeleteWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return createJSResponse(false, "WorldsService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.DeleteWorldRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.DeleteWorld(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// worldsServiceUpdateWorld handles the UpdateWorld method for WorldsService
func (exports *Weewar_v1_servicesServicesExports) worldsServiceUpdateWorld(this js.Value, args []js.Value) any {
	if exports.WorldsService == nil {
		return createJSResponse(false, "WorldsService not initialized", nil)
	}

	if len(args) < 1 {
		return createJSResponse(false, "Request JSON required", nil)
	}

	requestJSON := args[0].String()
	if requestJSON == "" {
		return createJSResponse(false, "Request JSON is empty", nil)
	}

	// Parse request
	var req *weewarv1.UpdateWorldRequest
	if err := protojson.Unmarshal([]byte(requestJSON), req); err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to parse request: %v", err), nil)
	}

	// Create context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Call service method
	resp, err := exports.WorldsService.UpdateWorld(ctx, req)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Service call failed: %v", err), nil)
	}

	// Marshal response
	responseJSON, err := protojson.Marshal(resp)
	if err != nil {
		return createJSResponse(false, fmt.Sprintf("Failed to marshal response: %v", err), nil)
	}

	return createJSResponse(true, "Success", json.RawMessage(responseJSON))
}

// =============================================================================
// Helper Functions
// =============================================================================

// createJSResponse creates a JavaScript-compatible response
func createJSResponse(success bool, message string, data any) any {
	response := map[string]any{
		"success": success,
		"message": message,
		"data":    data,
	}

	// Convert to JS Value
	responseBytes, err := json.Marshal(response)
	if err != nil {
		fmt.Printf("Failed to marshal JSON response: %v\n", err)
		// Return a simple error response
		errorResponse := map[string]any{
			"success": false,
			"message": fmt.Sprintf("JSON marshal error: %v", err),
			"data":    nil,
		}
		errorBytes, _ := json.Marshal(errorResponse)
		return js.Global().Get("JSON").Call("parse", string(errorBytes))
	}

	return js.Global().Get("JSON").Call("parse", string(responseBytes))
}
