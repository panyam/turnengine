// Code generated by protoc-gen-go-wasmjs. DO NOT EDIT.
// source: weewar/v1/models.proto
import {
		CreateGameRequest, 
		ListGamesRequest, 
		UpdateGameResponse, 
		ListMovesResponse, 
		ProcessMovesRequest, 
		GetOptionsAtRequest, 
		GetOptionsAtResponse, 
		GetGamesRequest, 
		GetGamesResponse, 
		ListGamesResponse, 
		UpdateGameRequest, 
		GetGameRequest, 
		GetGameResponse, 
		DeleteGameResponse, 
		GetGameStateResponse, 
		ListMovesRequest, 
		ProcessMovesResponse, 
		CreateGameResponse, 
		DeleteGameRequest, 
		GetGameStateRequest
} from '../../gen/weewar/v1/games_pb';
import {
		GetUserResponse, 
		DeleteUserResponse, 
		UpdateUserResponse, 
		CreateUserResponse, 
		GetUsersRequest, 
		ListUsersRequest, 
		ListUsersResponse, 
		GetUserRequest, 
		DeleteUserRequest, 
		UpdateUserRequest, 
		CreateUserRequest, 
		GetUsersResponse
} from '../../gen/weewar/v1/users_pb';
import {
		ListWorldsResponse, 
		DeleteWorldResponse, 
		UpdateWorldResponse, 
		GetWorldRequest, 
		GetWorldResponse, 
		DeleteWorldRequest, 
		UpdateWorldRequest, 
		CreateWorldRequest, 
		CreateWorldResponse, 
		GetWorldsRequest, 
		GetWorldsResponse, 
		ListWorldsRequest
} from '../../gen/weewar/v1/worlds_pb';

/**
 * WASM Response interface for all service calls
 */
export interface WASMResponse<T = any> {
    success: boolean;
    message: string;
    data: T;
}

/**
 * Error class for WASM-specific errors
 */
export class WasmError extends Error {
    constructor(message: string, public readonly methodPath?: string) {
        super(message);
        this.name = 'WasmError';
    }
}

/**
 * Protobuf-es style oneof representation
 */
export interface OneofValue<T = any> {
    case: string;
    value: T;
}

/**
 * Field metadata for conversion
 */
export interface FieldSchema {
    name: string;
    type: 'oneof' | 'message' | 'scalar' | 'repeated';
    oneofFields?: string[]; // For oneof: list of possible field names
}

/**
 * Message schema for conversion
 */
export interface MessageSchema {
    name: string;
    fields: Record<string, FieldSchema>;
}

/**
 * Conversion context passed to converters
 */
export interface ConversionContext {
    fieldName: string;
    fieldSchema?: FieldSchema;
    messageSchema?: MessageSchema;
    path: string[]; // Path to current field for debugging
}

/**
 * Conversion options for proto to JSON transformation
 */
export interface ConversionOptions {
    /**
     * Custom converter for oneof fields when receiving from WASM (response direction)
     * Input: Flattened Go representation
     * Output: { case: string, value: any } or similar for TypeScript
     * Set to 'auto' for automatic detection and conversion
     */
    oneofToJson?: ((oneofValue: any, context: ConversionContext) => any) | 'auto';
    
    /**
     * Custom converter for oneof fields when sending to WASM (request direction)
     * Input: { case: string, value: any } or similar
     * Output: Flattened representation for Go
     * Set to 'auto' for automatic detection and conversion
     */
    oneofFromJson?: ((jsonValue: any, context: ConversionContext) => any) | 'auto';
    
    /**
     * Schema provider for messages
     * Can be used to provide type information for better conversion
     */
    schemaProvider?: (messageName: string) => MessageSchema | undefined;
    
    /**
     * Custom field name transformer
     * Can be used to convert between camelCase and snake_case
     */
    fieldTransformer?: (fieldName: string) => string;
    
    /**
     * Whether to emit default values for fields
     */
    emitDefaults?: boolean;
    
    /**
     * Custom BigInt serialization
     */
    bigIntHandler?: (value: bigint) => string | number;
}
/**
 * GamesService service client interface
 */
export interface GamesServiceMethods {
	createGame(request: CreateGameRequest): Promise<CreateGameResponse>;
	getGames(request: GetGamesRequest): Promise<GetGamesResponse>;
	listGames(request: ListGamesRequest): Promise<ListGamesResponse>;
	getGame(request: GetGameRequest): Promise<GetGameResponse>;
	deleteGame(request: DeleteGameRequest): Promise<DeleteGameResponse>;
	updateGame(request: UpdateGameRequest): Promise<UpdateGameResponse>;
	getGameState(request: GetGameStateRequest): Promise<GetGameStateResponse>;
	listMoves(request: ListMovesRequest): Promise<ListMovesResponse>;
	processMoves(request: ProcessMovesRequest): Promise<ProcessMovesResponse>;
	getOptionsAt(request: GetOptionsAtRequest): Promise<GetOptionsAtResponse>;
}
/**
 * UsersService service client interface
 */
export interface UsersServiceMethods {
	createUser(request: CreateUserRequest): Promise<CreateUserResponse>;
	getUsers(request: GetUsersRequest): Promise<GetUsersResponse>;
	listUsers(request: ListUsersRequest): Promise<ListUsersResponse>;
	getUser(request: GetUserRequest): Promise<GetUserResponse>;
	deleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse>;
	updateUser(request: UpdateUserRequest): Promise<UpdateUserResponse>;
}
/**
 * WorldsService service client interface
 */
export interface WorldsServiceMethods {
	createWorld(request: CreateWorldRequest): Promise<CreateWorldResponse>;
	getWorlds(request: GetWorldsRequest): Promise<GetWorldsResponse>;
	listWorlds(request: ListWorldsRequest): Promise<ListWorldsResponse>;
	getWorld(request: GetWorldRequest): Promise<GetWorldResponse>;
	deleteWorld(request: DeleteWorldRequest): Promise<DeleteWorldResponse>;
	updateWorld(request: UpdateWorldRequest): Promise<UpdateWorldResponse>;
}

/**
 * weewar_v1_services WASM client
 * Provides a clean interface between UI components and the Go WASM service implementations
 */
export class Weewar_v1_servicesClient {
    private wasm: any;
    private wasmLoadPromise: Promise<void> | null = null;
    private conversionOptions: ConversionOptions = {
        oneofToJson: 'auto',
        oneofFromJson: 'auto',
        emitDefaults: false,
        bigIntHandler: (value: bigint) => value.toString()
    };

    // Service-specific clients
    public readonly gamesService: GamesServiceClientImpl;
    public readonly usersService: UsersServiceClientImpl;
    public readonly worldsService: WorldsServiceClientImpl;

    constructor(options?: Partial<ConversionOptions>) {
        if (options) {
            this.conversionOptions = { ...this.conversionOptions, ...options };
        }
        this.gamesService = new GamesServiceClientImpl(this);
        this.usersService = new UsersServiceClientImpl(this);
        this.worldsService = new WorldsServiceClientImpl(this);
    }

    /**
     * Load the WASM module asynchronously
     */
    public async loadWasm(wasmPath: string = './weewar_v1_services.wasm'): Promise<void> {
        if (this.wasmLoadPromise) {
            return this.wasmLoadPromise;
        }

        this.wasmLoadPromise = this.loadWASMModule(wasmPath);
        return this.wasmLoadPromise;
    }

    /**
     * Check if WASM is ready for operations
     */
    public isReady(): boolean {
        return this.wasm !== null && this.wasm !== undefined;
    }

    /**
     * Wait for WASM to be ready (use during initialization)
     */
    public async waitUntilReady(): Promise<void> {
        if (!this.wasmLoadPromise) {
            throw new Error('WASM loading not started. Call loadWasm() first.');
        }
        await this.wasmLoadPromise;
    }

    /**
     * Configure conversion options at runtime
     */
    public setConversionOptions(options: Partial<ConversionOptions>): void {
        this.conversionOptions = { ...this.conversionOptions, ...options };
    }

    /**
     * Internal method to call WASM functions with type conversion
     */
    public callMethod<TRequest, TResponse>(
        methodPath: string,
        request: TRequest,
        requestMessageName?: string,
        responseMessageName?: string
    ): Promise<TResponse> {
        this.ensureWASMLoaded();

        try {
            // Get schema if available
            const requestSchema = requestMessageName && this.conversionOptions.schemaProvider
                ? this.conversionOptions.schemaProvider(requestMessageName)
                : undefined;
            
            // Convert request to JSON with custom handling
            const jsonReq = this.convertToJson(request, requestSchema);
            const wasmMethod = this.getWasmMethod(methodPath);
            const wasmResponse = wasmMethod(JSON.stringify(jsonReq));

            if (!wasmResponse.success) {
                throw new WasmError(wasmResponse.message, methodPath);
            }

            // Get response schema if available
            const responseSchema = responseMessageName && this.conversionOptions.schemaProvider
                ? this.conversionOptions.schemaProvider(responseMessageName)
                : undefined;

            // Convert response from JSON with custom handling
            return this.convertFromJson(wasmResponse.data, (request as any).constructor, responseSchema);
        } catch (error) {
            if (error instanceof WasmError) {
                throw error;
            }
            throw new WasmError(
                `Proto conversion error: ${error instanceof Error ? error.message : String(error)}`,
                methodPath
            );
        }
    }

    /**
     * Load the WASM module implementation
     */
    private async loadWASMModule(wasmPath: string): Promise<void> {
        console.log('Loading weewar_v1_services WASM module...');

        // Check if WASM is already loaded (for testing environments)
        if ((window as any).weewar) {
            console.log('WASM module already loaded (pre-loaded in test environment)');
            this.wasm = (window as any).weewar;
            return;
        }

        // Load Go's WASM support
        if (!(window as any).Go) {
            const script = document.createElement('script');
            script.src = '/static/wasm/wasm_exec.js';
            document.head.appendChild(script);

            await new Promise<void>((resolve, reject) => {
                script.onload = () => resolve();
                script.onerror = () => reject(new Error('Failed to load wasm_exec.js'));
            });
        }

        // Initialize Go WASM runtime
        const go = new (window as any).Go();
        const wasmModule = await WebAssembly.instantiateStreaming(
            fetch(wasmPath),
            go.importObject
        );

        // Run the WASM module
        go.run(wasmModule.instance);

        // Verify WASM APIs are available
        if (!(window as any).weewar) {
            throw new Error('WASM APIs not found - module may not have loaded correctly');
        }
        this.wasm = (window as any).weewar;

        console.log('weewar_v1_services WASM module loaded successfully');
    }

    /**
     * Ensure WASM module is loaded (synchronous version for service calls)
     */
    private ensureWASMLoaded(): void {
        if (!this.isReady()) {
            throw new Error('WASM module not loaded. Call loadWasm() and waitUntilReady() first.');
        }
    }

    /**
     * Get WASM method function by path
     */
    private getWasmMethod(methodPath: string): Function {
        // Handle namespaced structure: namespace.service.method
        const parts = methodPath.split('.');
        let current = this.wasm;
        for (const part of parts) {
            current = current[part];
            if (!current) {
                throw new Error(`Method not found: ${methodPath}`);
            }
        }
        return current;
    }

    /**
     * Convert request to JSON with custom handling
     */
    private convertToJson(request: any, schema?: MessageSchema): any {
        // First try native toJson/toJSON methods
        const nativeMethod = this.detectToJson(request);
        if (nativeMethod !== this.fallbackToJson) {
            const result = nativeMethod(request);
            return this.applyCustomConversions(result, 'request', schema);
        }
        
        // Use fallback with custom conversions
        return this.applyCustomConversions(
            this.fallbackToJson(request),
            'request',
            schema
        );
    }

    /**
     * Convert response from JSON with custom handling
     */
    private convertFromJson(json: any, constructor: any, schema?: MessageSchema): any {
        // Apply custom conversions before native parsing
        const processedJson = this.applyCustomConversions(json, 'response', schema);
        
        // Try native fromJson/fromJSON methods
        const nativeMethod = this.detectFromJson(constructor);
        if (nativeMethod !== this.fallbackFromJson) {
            return nativeMethod(processedJson);
        }
        
        // Use fallback
        return this.fallbackFromJson(processedJson);
    }

    /**
     * Apply custom conversions for better Go compatibility
     */
    private applyCustomConversions(
        obj: any, 
        direction: 'request' | 'response', 
        schema?: MessageSchema,
        path: string[] = []
    ): any {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }

        const result: any = Array.isArray(obj) ? [] : {};

        for (const [key, value] of Object.entries(obj)) {
            let processedKey = key;
            let processedValue = value;
            const currentPath = [...path, key];

            // Get field schema if available
            const fieldSchema = schema?.fields[key];

            // Apply field name transformation if configured
            if (this.conversionOptions.fieldTransformer) {
                processedKey = this.conversionOptions.fieldTransformer(key);
            }

            // Handle oneof fields
            if (fieldSchema?.type === 'oneof' || (!fieldSchema && this.isOneofField(obj, key))) {
                const context: ConversionContext = {
                    fieldName: key,
                    fieldSchema,
                    messageSchema: schema,
                    path: currentPath
                };

                if (direction === 'request' && this.conversionOptions.oneofFromJson) {
                    if (this.conversionOptions.oneofFromJson === 'auto') {
                        // Auto conversion: flatten { case: "fieldName", value: {...} } to { fieldName: {...} }
                        if (this.isOneofValue(value)) {
                            processedKey = value.case;
                            processedValue = this.applyCustomConversions(value.value, direction, undefined, currentPath);
                        } else if (value && typeof value === 'object' && Object.keys(value).length === 1) {
                            // Already flattened or simple oneof
                            const [innerKey, innerValue] = Object.entries(value)[0];
                            processedKey = innerKey;
                            processedValue = this.applyCustomConversions(innerValue, direction, undefined, currentPath);
                        }
                    } else {
                        // Custom converter
                        const converted = this.conversionOptions.oneofFromJson(value, context);
                        if (converted && typeof converted === 'object' && !Array.isArray(converted)) {
                            // If converter returns an object with multiple fields, merge it
                            for (const [convKey, convValue] of Object.entries(converted)) {
                                result[convKey] = this.applyCustomConversions(convValue, direction, undefined, [...path, convKey]);
                            }
                            continue; // Skip normal assignment
                        } else {
                            processedValue = converted;
                        }
                    }
                } else if (direction === 'response' && this.conversionOptions.oneofToJson) {
                    if (this.conversionOptions.oneofToJson === 'auto') {
                        // Auto conversion for response is tricky without knowing which field is set
                        // For now, pass through and let the TypeScript protobuf library handle it
                        processedValue = this.applyCustomConversions(value, direction, undefined, currentPath);
                    } else {
                        // Custom converter
                        processedValue = this.conversionOptions.oneofToJson(value, context);
                    }
                }
            } else if (value !== null && typeof value === 'object') {
                // Recursively process nested objects
                // For nested messages, we might have schema info
                const nestedSchema = fieldSchema?.type === 'message' && this.conversionOptions.schemaProvider
                    ? this.conversionOptions.schemaProvider(fieldSchema.name)
                    : undefined;
                processedValue = this.applyCustomConversions(value, direction, nestedSchema, currentPath);
            } else if (typeof value === 'bigint' && direction === 'request') {
                // Handle BigInt serialization
                processedValue = this.conversionOptions.bigIntHandler
                    ? this.conversionOptions.bigIntHandler(value)
                    : value.toString();
            } else if (typeof value === 'string' && /^\d+$/.test(value) && direction === 'response') {
                // Potentially handle BigInt deserialization based on field context
                // This would need more sophisticated field type tracking
                processedValue = value;
            }

            // Handle default values
            if (!this.conversionOptions.emitDefaults && 
                direction === 'request' && 
                this.isDefaultValue(processedValue)) {
                continue;
            }

            result[processedKey] = processedValue;
        }

        return result;
    }

    /**
     * Type guard for protobuf-es oneof values
     */
    private isOneofValue(value: any): value is OneofValue {
        return value && 
               typeof value === 'object' && 
               !Array.isArray(value) &&
               'case' in value && 
               'value' in value &&
               typeof value.case === 'string';
    }

    /**
     * Check if a field might be a oneof
     * This is a heuristic - ideally we'd have type information
     */
    private isOneofField(parent: any, fieldName: string): boolean {
        // Common patterns for oneof fields in protobuf-es:
        // 1. Has 'case' and 'value' properties (protobuf-es pattern)
        // 2. Field name pattern (e.g., ends with 'Case' or starts with 'oneof')
        const value = parent[fieldName];
        
        if (!value || typeof value !== 'object' || Array.isArray(value)) {
            return false;
        }
        
        // Check for protobuf-es oneof pattern using type guard
        if (this.isOneofValue(value)) {
            return true;
        }
        
        // Legacy check: object with single property (older pattern or already flattened)
        const keys = Object.keys(value);
        if (keys.length === 1) {
            // This might be a simple oneof with just the active field
            return true;
        }
        
        return false;
    }

    /**
     * Check if a value is a default value that should be omitted
     */
    private isDefaultValue(value: any): boolean {
        return value === null || 
               value === undefined || 
               value === '' || 
               value === 0 || 
               value === false ||
               (Array.isArray(value) && value.length === 0) ||
               (typeof value === 'object' && Object.keys(value).length === 0);
    }

    /**
     * Fallback toJson implementation
     */
    private fallbackToJson(obj: any): any {
        return JSON.parse(JSON.stringify(obj, (key, value) => {
            if (typeof value === 'bigint') {
                return this.conversionOptions.bigIntHandler
                    ? this.conversionOptions.bigIntHandler(value)
                    : value.toString();
            }
            return value;
        }));
    }

    /**
     * Fallback fromJson implementation
     */
    private fallbackFromJson(json: any): any {
        // Simple pass-through for objects that don't have fromJson
        return json;
    }

    /**
     * Auto-detect toJson conversion method
     */
    private detectToJson(request: any): (req: any) => any {
        return (request as any).toJson || 
               (request as any).toJSON || 
               this.fallbackToJson.bind(this);
    }

    /**
     * Auto-detect fromJson conversion method
     */
    private detectFromJson(constructor: any): (json: any) => any {
        return constructor.fromJson || 
               constructor.fromJSON || 
               this.fallbackFromJson.bind(this);
    }
}
/**
 * GamesService service client implementation
 */
class GamesServiceClientImpl implements GamesServiceMethods {
    constructor(private parent: Weewar_v1_servicesClient) {}
    async createGame(request: CreateGameRequest): Promise<CreateGameResponse> {
        return this.parent.callMethod('gamesService.createGame', request, 'CreateGameRequest', 'CreateGameResponse');
    }
    async getGames(request: GetGamesRequest): Promise<GetGamesResponse> {
        return this.parent.callMethod('gamesService.getGames', request, 'GetGamesRequest', 'GetGamesResponse');
    }
    async listGames(request: ListGamesRequest): Promise<ListGamesResponse> {
        return this.parent.callMethod('gamesService.listGames', request, 'ListGamesRequest', 'ListGamesResponse');
    }
    async getGame(request: GetGameRequest): Promise<GetGameResponse> {
        return this.parent.callMethod('gamesService.getGame', request, 'GetGameRequest', 'GetGameResponse');
    }
    async deleteGame(request: DeleteGameRequest): Promise<DeleteGameResponse> {
        return this.parent.callMethod('gamesService.deleteGame', request, 'DeleteGameRequest', 'DeleteGameResponse');
    }
    async updateGame(request: UpdateGameRequest): Promise<UpdateGameResponse> {
        return this.parent.callMethod('gamesService.updateGame', request, 'UpdateGameRequest', 'UpdateGameResponse');
    }
    async getGameState(request: GetGameStateRequest): Promise<GetGameStateResponse> {
        return this.parent.callMethod('gamesService.getGameState', request, 'GetGameStateRequest', 'GetGameStateResponse');
    }
    async listMoves(request: ListMovesRequest): Promise<ListMovesResponse> {
        return this.parent.callMethod('gamesService.listMoves', request, 'ListMovesRequest', 'ListMovesResponse');
    }
    async processMoves(request: ProcessMovesRequest): Promise<ProcessMovesResponse> {
        return this.parent.callMethod('gamesService.processMoves', request, 'ProcessMovesRequest', 'ProcessMovesResponse');
    }
    async getOptionsAt(request: GetOptionsAtRequest): Promise<GetOptionsAtResponse> {
        return this.parent.callMethod('gamesService.getOptionsAt', request, 'GetOptionsAtRequest', 'GetOptionsAtResponse');
    }
}
/**
 * UsersService service client implementation
 */
class UsersServiceClientImpl implements UsersServiceMethods {
    constructor(private parent: Weewar_v1_servicesClient) {}
    async createUser(request: CreateUserRequest): Promise<CreateUserResponse> {
        return this.parent.callMethod('usersService.createUser', request, 'CreateUserRequest', 'CreateUserResponse');
    }
    async getUsers(request: GetUsersRequest): Promise<GetUsersResponse> {
        return this.parent.callMethod('usersService.getUsers', request, 'GetUsersRequest', 'GetUsersResponse');
    }
    async listUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
        return this.parent.callMethod('usersService.listUsers', request, 'ListUsersRequest', 'ListUsersResponse');
    }
    async getUser(request: GetUserRequest): Promise<GetUserResponse> {
        return this.parent.callMethod('usersService.getUser', request, 'GetUserRequest', 'GetUserResponse');
    }
    async deleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
        return this.parent.callMethod('usersService.deleteUser', request, 'DeleteUserRequest', 'DeleteUserResponse');
    }
    async updateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
        return this.parent.callMethod('usersService.updateUser', request, 'UpdateUserRequest', 'UpdateUserResponse');
    }
}
/**
 * WorldsService service client implementation
 */
class WorldsServiceClientImpl implements WorldsServiceMethods {
    constructor(private parent: Weewar_v1_servicesClient) {}
    async createWorld(request: CreateWorldRequest): Promise<CreateWorldResponse> {
        return this.parent.callMethod('worldsService.createWorld', request, 'CreateWorldRequest', 'CreateWorldResponse');
    }
    async getWorlds(request: GetWorldsRequest): Promise<GetWorldsResponse> {
        return this.parent.callMethod('worldsService.getWorlds', request, 'GetWorldsRequest', 'GetWorldsResponse');
    }
    async listWorlds(request: ListWorldsRequest): Promise<ListWorldsResponse> {
        return this.parent.callMethod('worldsService.listWorlds', request, 'ListWorldsRequest', 'ListWorldsResponse');
    }
    async getWorld(request: GetWorldRequest): Promise<GetWorldResponse> {
        return this.parent.callMethod('worldsService.getWorld', request, 'GetWorldRequest', 'GetWorldResponse');
    }
    async deleteWorld(request: DeleteWorldRequest): Promise<DeleteWorldResponse> {
        return this.parent.callMethod('worldsService.deleteWorld', request, 'DeleteWorldRequest', 'DeleteWorldResponse');
    }
    async updateWorld(request: UpdateWorldRequest): Promise<UpdateWorldResponse> {
        return this.parent.callMethod('worldsService.updateWorld', request, 'UpdateWorldRequest', 'UpdateWorldResponse');
    }
}

// Export the main client class
export default Weewar_v1_servicesClient;
