package services

import (
	"fmt"
	"strings"
	"time"
)

type StringMapField struct {
	Properties map[string]any
}

type BaseModel struct {
	CreatedAt time.Time `datastore:"createdAt" json:"createdAt"`
	UpdatedAt time.Time `datastore:"updatedAt" json:"updatedAt"`
	Version   int       `datastore:"version" json:"version"` // used for optimistic locking
}

// An ID Generated by our system
type GenID struct {
	BaseModel
	Id        string `datastore:"id" json:"id"`
	OwnerId   string
	ExpiresAt time.Time
}

type Tag struct {
	BaseModel
	Name           string
	NormalizedName string
	Description    string
	ImageUrl       string
	FirstUserId    string `datastore:"firstUser" json:"firstUser"`
	NumAppItems    int64
}

type AppItem struct {
	BaseModel
	Id         string   `datastore:"id" json:"id"`
	OwnerId    string   `datastore:"ownerId" json:"ownerId"`
	Visibility string   `datastore:"visibility" json:"visibility"`
	VisibleTo  []string `datastore:"visibleTo" json:"visibleTo"`

	/**
	 * Name of the appitem
	 */
	Name string `datastore:"name" json:"name"`

	/**
	 * Description of this appitem.
	 */
	Description string `datastore:"description" json:"description"`

	// Metadata about the content itself that user may want to
	// highlight (or the system extracts)
	// ContentMetadata StringMapField `datastore:"contentMetadata,noindex" json:"contentMetadata,noindex"`
}

/**
 * An identify is a unique global "address" corresponding to a user.
 * For example the identify abc@example.com is a unique identify regardless
 * of which Channel is verifying it.  Multiple channels can verify the same
 * entity, eg open auth by github, FB or Google can verify the same email
 * address.
 */
type Identity struct {
	BaseModel
	IsActive bool `datastore:"isActive" json:"isActive"`

	// Type of identity being verified (eg email, phone etc).
	IdentityType string `datastore:"identityType" json:"identityType"`

	// The key specific to the identity (eg an email address or a phone number etc).
	//
	// type + key should be unique through out the system.
	IdentityKey string `datastore:"identityKey" json:"identityKey"`

	// The primary user that this identity can be associated with.
	// Identities do not need to be explicitly associted with a user especially
	// in systems where a single Identity can be used to front several users
	PrimaryUser string `datastore:"primaryUser" json:"primaryUser"`
}

func (i *Identity) HasUser() bool {
	return strings.TrimSpace(i.PrimaryUser) != ""
}

func (i *Identity) HasKey() bool {
	return strings.TrimSpace(i.IdentityType) != "" && strings.TrimSpace(i.IdentityKey) != ""
}

func (i *Identity) Key() string {
	out := fmt.Sprintf("%s:%s", i.IdentityType, i.IdentityKey)
	if out == ":" {
		out = ""
	}
	return out
}

/**
 * Once a channel has verified an Identity, the end result is a mapping to
 * a local user object that is the entry for authenticated actions within
 * the system.  The User can also mean a user profile and can be extended
 * to be customized by the user of this library in their own specific app.
 */
type User struct {
	BaseModel

	Id string `datastore:"id" json:"id"`

	IsActive bool `datastore:"isActive" json:"isActive"`
	// A globally unique user ID.  This User ID cannot be used as a login key.
	// Login's need to happen via the Identiites above and a username could be
	// one of the identities (which can be verified say via login/password mechanism)
	// Alternatively an email can be used as an identity that can also map to
	// a particular user.
	// Name    string `datastore:"name" json:"name"`
	// Email   string `datastore:"email" json:"email"`
	// Picture string `datastore:"picture" json:"picture"`
	Profile StringMapField `datastore:"profile" json:"profile"`
}

type AuthFlow struct {
	BaseModel

	Id string `datastore:"id" json:"id"`

	// Kind of login being done
	Provider string `datastore:"provider" json:"provider"`

	// When this Auth session expires;
	ExpiresIn time.Time `datastore:"expiresIn" json:"expiresIn"`

	// Call back URL for where the session needs to endup on success
	// callback: CallbackRequest;

	// Handler that will continue the flow after a successful AuthFlow.
	HandlerName string `datastore:"handlerName" json:"handlerName"`

	// Parameters for the handler to continue with.
	HandlerParams StringMapField `datastore:"handlerParams" json:"handlerParams"`
}

/**
 * Channel's represented federated verification objects.  For example a Google
 * Signin would ensure that the user that goes through this flow will end up with
 * a Google signin Channel - which would verify a particular identity type.
 */
type Channel struct {
	BaseModel
	Provider string `datastore:"provider" json:"provider"`
	LoginId  string `datastore:"loginId" json:"loginId"`

	/**
	 * Credentials for this channel (like access tokens, passwords etc).
	 */
	Credentials StringMapField `datastore:"credentials" json:"credentials"`

	/**
	 * Profile as passed by the provider of the channel.
	 */
	Profile StringMapField `datastore:"profile" json:"profile"`

	/**
	 * When does this channel expire and needs another login/auth.
	 */
	ExpiresIn time.Time `datastore:"expiresIn" json:"expiresIn"`

	// The identity that this channel is verifying.
	IdentityKey string `datastore:"identityKey" json:"identityKey"`
}

func (c *Channel) HasKey() bool {
	return strings.TrimSpace(c.Provider) != "" && strings.TrimSpace(c.LoginId) != ""
}

func (c *Channel) Key() string {
	return c.Provider + ":" + c.LoginId
}

func (c *Channel) HasIdentity() bool {
	return strings.TrimSpace(c.IdentityKey) != ""
}
